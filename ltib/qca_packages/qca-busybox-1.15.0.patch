From 0cd907124b6e0f0dea6bd7f6b7593ce4bfeb4b55 Mon Sep 17 00:00:00 2001
From: Nathaniel Houghton <nhoughto@qca.qualcomm.com>
Date: Tue, 3 Jan 2012 09:50:57 -0500
Subject: [PATCH 1/2] add N_QCA line discipline;
 update slattach to support it;

---
 busybox-1.15.0/networking/slattach.c |   27 +++++++++++++++++----------
 1 files changed, 17 insertions(+), 10 deletions(-)

diff --git a/busybox-1.15.0/networking/slattach.c b/busybox-1.15.0/networking/slattach.c
index d3212bb..52a14b3 100644
--- a/busybox-1.15.0/networking/slattach.c
+++ b/busybox-1.15.0/networking/slattach.c
@@ -16,6 +16,9 @@
 #include "libbb.h"
 #include "libiproute/utils.h" /* invarg() */
 
+/* not defined in ioctl-types.h */
+#define N_QCA 22
+
 struct globals {
 	int handle;
 	int saved_disc;
@@ -94,23 +97,21 @@ static void restore_state_and_exit(int exitcode)
 /*
  * Set tty state, line discipline and encapsulation
  */
-static void set_state(struct termios *state, int encap)
+static void set_state(struct termios *state, int disc, int encap)
 {
-	int disc;
-
 	/* Set line status */
 	if (set_termios_state_or_warn(state))
 		goto bad;
-	/* Set line discliple (N_SLIP always) */
-	disc = N_SLIP;
 	if (ioctl_or_warn(handle, TIOCSETD, &disc) < 0) {
 		goto bad;
 	}
 
-	/* Set encapsulation (SLIP, CSLIP, etc) */
-	if (ioctl_or_warn(handle, SIOCSIFENCAP, &encap) < 0) {
+	if (disc == N_SLIP) {
+		/* Set encapsulation (SLIP, CSLIP, etc) */
+		if (ioctl_or_warn(handle, SIOCSIFENCAP, &encap) < 0) {
  bad:
 		restore_state_and_exit(EXIT_FAILURE);
+		}
 	}
 }
 
@@ -129,6 +130,7 @@ int slattach_main(int argc UNUSED_PARAM, char **argv)
 		"slip6\0"       /* 2 */
 		"cslip6\0"      /* 3 */
 		"adaptive\0"    /* 8 */
+		"qca\0"		/* 22 */
 		;
 
 	int i, encap, opt;
@@ -136,6 +138,7 @@ int slattach_main(int argc UNUSED_PARAM, char **argv)
 	const char *proto = "cslip";
 	const char *extcmd;				/* Command to execute after hangup */
 	const char *baud_str;
+	int line_disc;
 	int baud_code = -1;				/* Line baud rate (system code) */
 
 	enum {
@@ -161,10 +164,14 @@ int slattach_main(int argc UNUSED_PARAM, char **argv)
 
 	encap = index_in_strings(proto_names, proto);
 
-	if (encap < 0)
+	line_disc = N_SLIP;
+	if (encap < 0) {
 		invarg(proto, "protocol");
-	if (encap > 3)
+	} else if (encap == 4) {
 		encap = 8;
+	} else if (encap == 5) {
+		line_disc = N_QCA;
+	}
 
 	/* We want to know if the baud rate is valid before we start touching the ttys */
 	if (opt & OPT_s_baud) {
@@ -215,7 +222,7 @@ int slattach_main(int argc UNUSED_PARAM, char **argv)
 		cfsetospeed(&state, baud_code);
 	}
 
-	set_state(&state, encap);
+	set_state(&state, line_disc, encap);
 
 	/* Exit now if option -e was passed */
 	if (opt & OPT_e_quit)
-- 
1.7.4.1


From bf6a51a6a72149135a6ec85bdfb36af9f0ac3b58 Mon Sep 17 00:00:00 2001
From: Nathaniel Houghton <nhoughto@qca.qualcomm.com>
Date: Mon, 23 Jan 2012 09:48:28 -0500
Subject: [PATCH 2/2] add parity selection in slattach with -P;

---
 busybox-1.15.0/include/usage.h       |   19 ++++++++++---------
 busybox-1.15.0/networking/slattach.c |   31 ++++++++++++++++++++++++++++---
 2 files changed, 38 insertions(+), 12 deletions(-)

diff --git a/busybox-1.15.0/include/usage.h b/busybox-1.15.0/include/usage.h
index 227ed80..04713cb 100644
--- a/busybox-1.15.0/include/usage.h
+++ b/busybox-1.15.0/include/usage.h
@@ -3932,18 +3932,19 @@
      "\n	-s	Display raw scan-codes" \
 
 #define slattach_trivial_usage \
-       "[-cehmLF] [-s SPEED] [-p PROTOCOL] DEVICE"
+       "[-cehmLF] [-s SPEED] [-p PROTOCOL] [-P PARITY] DEVICE"
 #define slattach_full_usage "\n\n" \
        "Attach network interface(s) to serial line(s)\n" \
      "\nOptions:" \
-     "\n	-p PROT	Set protocol (slip, cslip, slip6, clisp6 or adaptive)" \
-     "\n	-s SPD	Set line speed" \
-     "\n	-e	Exit after initializing device" \
-     "\n	-h	Exit when the carrier is lost" \
-     "\n	-c PROG	Run PROG when the line is hung up" \
-     "\n	-m	Do NOT initialize the line in raw 8 bits mode" \
-     "\n	-L	Enable 3-wire operation" \
-     "\n	-F	Disable RTS/CTS flow control" \
+     "\n	-p PROT		Set protocol (slip, cslip, slip6, clisp6 or adaptive)" \
+     "\n	-s SPD		Set line speed" \
+     "\n	-e		Exit after initializing device" \
+     "\n	-h		Exit when the carrier is lost" \
+     "\n	-c PROG		Run PROG when the line is hung up" \
+     "\n	-m		Do NOT initialize the line in raw 8 bits mode" \
+     "\n	-L		Enable 3-wire operation" \
+     "\n	-F		Disable RTS/CTS flow control" \
+     "\n	-P PARITY	Use PARITY (even|odd|none). Default is none." \
 
 #define sleep_trivial_usage \
 	IF_FEATURE_FANCY_SLEEP("[") "N" IF_FEATURE_FANCY_SLEEP("]...")
diff --git a/busybox-1.15.0/networking/slattach.c b/busybox-1.15.0/networking/slattach.c
index 52a14b3..ad0db0b 100644
--- a/busybox-1.15.0/networking/slattach.c
+++ b/busybox-1.15.0/networking/slattach.c
@@ -120,6 +120,10 @@ static void sig_handler(int signo UNUSED_PARAM)
 	restore_state_and_exit(EXIT_SUCCESS);
 }
 
+#define PARITY_NONE 0
+#define PARITY_EVEN 1
+#define PARITY_ODD  2
+
 int slattach_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int slattach_main(int argc UNUSED_PARAM, char **argv)
 {
@@ -140,6 +144,8 @@ int slattach_main(int argc UNUSED_PARAM, char **argv)
 	const char *baud_str;
 	int line_disc;
 	int baud_code = -1;				/* Line baud rate (system code) */
+	const char *parity = "none";
+	int parity_code = PARITY_NONE;
 
 	enum {
 		OPT_p_proto  = 1 << 0,
@@ -149,13 +155,14 @@ int slattach_main(int argc UNUSED_PARAM, char **argv)
 		OPT_h_watch  = 1 << 4,
 		OPT_m_nonraw = 1 << 5,
 		OPT_L_local  = 1 << 6,
-		OPT_F_noflow = 1 << 7
+		OPT_F_noflow = 1 << 7,
+		OPT_P_parity = 1 << 8
 	};
 
 	INIT_G();
 
 	/* Parse command line options */
-	opt = getopt32(argv, "p:s:c:ehmLF", &proto, &baud_str, &extcmd);
+	opt = getopt32(argv, "p:s:c:ehmLFP:", &proto, &baud_str, &extcmd, &parity);
 	/*argc -= optind;*/
 	argv += optind;
 
@@ -180,6 +187,18 @@ int slattach_main(int argc UNUSED_PARAM, char **argv)
 			invarg(baud_str, "baud rate");
 	}
 
+	if (opt & OPT_P_parity) {
+		if (!strcasecmp("even", parity)) {
+			parity_code = PARITY_EVEN;
+		} else if (!strcasecmp("odd", parity)) {
+			parity_code = PARITY_ODD;
+		} else if (!strcasecmp("none", parity)) {
+			parity_code = PARITY_NONE;
+		} else {
+			invarg(parity, "parity");
+		}
+	}
+
 	/* Trap signals in order to restore tty states upon exit */
 	if (!(opt & OPT_e_quit)) {
 		bb_signals(0
@@ -207,12 +226,18 @@ int slattach_main(int argc UNUSED_PARAM, char **argv)
 	if (!(opt & OPT_m_nonraw)) { /* raw not suppressed */
 		memset(&state.c_cc, 0, sizeof(state.c_cc));
 		state.c_cc[VMIN] = 1;
-		state.c_iflag = IGNBRK | IGNPAR;
+		state.c_iflag = IGNBRK;
+		if (parity_code == PARITY_NONE) {
+			state.c_iflag |= IGNPAR;
+		}
 		state.c_oflag = 0;
 		state.c_lflag = 0;
 		state.c_cflag = CS8 | HUPCL | CREAD
 		              | ((opt & OPT_L_local) ? CLOCAL : 0)
 		              | ((opt & OPT_F_noflow) ? 0 : CRTSCTS);
+		if (parity_code != PARITY_NONE) {
+			state.c_cflag |= PARENB | (parity_code == PARITY_ODD ? PARODD : 0);
+		}
 		cfsetispeed(&state, cfgetispeed(&saved_state));
 		cfsetospeed(&state, cfgetospeed(&saved_state));
 	}
-- 
1.7.4.1

